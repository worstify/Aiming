if(getgenv()).Aiming then return(getgenv()).Aiming end local a=(loadstring(game:HttpGet("https://raw.githubusercontent.com/Stefanuk12/Signal/main/Manager.lua")))()local b=(loadstring(game:HttpGet("https://raw.githubusercontent.com/Stefanuk12/Aiming/main/BeizerManager.lua")))()local c=game:GetService("Players")local d=game:GetService("Workspace")local e=game:GetService("GuiService")local f=game:GetService("RunService")local g=game:GetService("UserInputService")local h=f.Heartbeat local i=c.LocalPlayer local j=Drawing.new local k=Color3.fromRGB local l=e.GetGuiInset local m=Random.new local n=math.floor local o=RaycastParams.new local p=Enum.RaycastFilterType.Blacklist local q=d.Raycast local r=c.GetPlayers local s=Instance.new local t=(s("Camera")).WorldToViewportPoint local u=(s("Part")).IsDescendantOf local v=(s("Part")).FindFirstChildWhichIsA local w=(s("Part")).FindFirstChild local x=table.remove local y=table.insert local z=g.GetMouseLocation local A=CFrame.lookAt local B=Vector2.new local C=(s("Part")).GetChildren local D={Enabled=true;VisibleCheck=true;HitChance=100;TargetPart={"Head";"HumanoidRootPart"};RaycastIgnore=nil;Offset=B(),FOVSettings={Circle=j("Circle");Enabled=true;Scale=60,Sides=12;Colour=k(231,84,128)};TracerSettings={Tracer=j("Line"),Enabled=true;Colour=k(231,84,128)},Ignored={WhitelistMode={Players=false;Teams=false};Teams={};IgnoreLocalTeam=true;Players={i,91318356}}}local E={Loaded=false;ShowCredits=true;Settings=D,Signals=a.new();Selected={Instance=nil,Part=nil,Position=nil,Velocity=nil;OnScreen=false}};(getgenv()).Aiming=E function D.Get(...)local a={...}local b=#a local c=a[b]local d=D for b=1,b-1,1 do local c=a[b]if c then d=d[c]end end return d[c]end do local a={"InstanceChanged","PartChanged","PartPositionChanged","OnScreenChanged"}for a,b in pairs(a)do E.Signals:Create(b)end end local F=D.FOVSettings.Circle F.Transparency=1 F.Thickness=2 F.Color=D.FOVSettings.Colour F.Filled=false function E.UpdateFOV()if not F then return end local a=z(g)+D.Offset local b=D.FOVSettings F.Visible=b.Enabled F.Radius=b.Scale*3 F.Position=a F.NumSides=b.Sides F.Color=b.Colour return F end local G=D.TracerSettings.Tracer function E.UpdateTracer()if not G then return end local a=z(g)+D.Offset local b=D.TracerSettings local c=E.Selected.Position local d=E.Checks.IsAvailable()if d then G.Visible=b.Enabled G.Color=b.Colour G.From=a G.To=c else G.Visible=false end return G end local H={}E.Utilities=H local I do function H.GetPlayers()return r(c)end function H.GetCurrentCamera()return d.CurrentCamera end I=H.GetCurrentCamera function H.CalculateVelocity(a,b,c)local d=b-a local e=d/c return e end function H.CalculateChance(a)a=n(a)local b=n((m()).NextNumber(m(),0,1)*100)/100 return b<=a/100 end function H.Character(a)return a.Character end function H.GetBodyParts(a)local b=a:GetChildren()for a=#b,1,-1 do if not b[a]:IsA("BasePart")then table.remove(b,a)end end return b end function H.ArrayToString(a,b)b=b or tostring for c,d in pairs(a)do a[c]=b(d)end return a end function H.TeamMatch(a,b)if a:IsA("Player")then a=a.Team end if b:IsA("Player")then b=b.Team end return a==b end function H.IsPartVisible(a,b)local c=H.Character(i)local e=(I()).CFrame.Position local f,g=t(I(),a.Position)if g then local f=o()f.FilterType=p local g=D.RaycastIgnore f.FilterDescendantsInstances=typeof(g)=="function"and g()or g or{c;I()}local h=q(d,e,a.Position-e,f)if h then local c=h.Instance local d=c==a or u(c,b)return d end end return false end function H.Raycast(a,b,c)if typeof(a)=="Vector3"and typeof(b)=="Vector3"then if not c then c=1 end local e=(b-a).Unit*c local f=q(d,a,e)if f then local a=f.Normal local b=f.Material return e,a,b end end return nil end function H.SetCameraCFrame(a)(I()).CFrame=a end function H.CameraLookAt(a)local b=A((I()).CFrame.Position,a)H.SetCameraCFrame(b)end function H.ClosestPointOnObject(a,b)local c=b.Position local d=b.Size if typeof(a)=="Ray"then if a.Direction.Magnitude~=1 then a=a.Unit end local b=(c-a.Origin).Magnitude a=a.Origin+a.Direction*b end local e=c+Vector3.new(0,-c.Y+a.Y,0)local f=c+d/2 local g=c-d/2 local h=(a.Y>=g.Y and a.Y<=f.Y)and e or c local i=h-a local j=RaycastParams.new()j.FilterType=Enum.RaycastFilterType.Whitelist j.FilterDescendantsInstances={b}local k=workspace:Raycast(a,i,j)return k.Position end function H.SolveProjectileTravelTime(a,b,c,d)local e=c-a local f=Vector3.new(e.X,0,e.Z)local g=f.Magnitude local h=b*b local i=h*h local j=e.Y local k=d*g local l=i-d*((d*g)*g+(2*j)*h)if l<0 then return nil end l=math.sqrt(l)local m=math.atan2(h-l,k)local n=(f.Unit*math.cos(m))*b+(Vector3.new(0,1,0)*math.sin(m))*b local o=g/(math.cos(m)*b)return n,o end function H.SolvePrediction(a,b,c)return a+b*c end function H.WorkoutDirection(a,b,c,d,e)local f,g=H.SolveProjectileTravelTime(a,d,b,e)local h=H.SolvePrediction(b,c,g)local i=H.SolveProjectileTravelTime(a,d,h,e)return i end end local J={}E.Ignored=J do local a=E.Settings.Ignored local b=a.WhitelistMode function J.IgnorePlayer(b)local c=a.Players for a,c in pairs(c)do if c==b then return false end end y(c,b)return true end function J.UnIgnorePlayer(b)local c=a.Players for a,d in pairs(c)do if d==b then x(c,a)return true end end return false end function J.IgnoreTeam(b,c)local d=a.Teams for a,d in pairs(d)do if d.Team==b and d.TeamColor==c then return false end end y(d,{b,c})return true end function J.UnIgnoreTeam(b,c)local d=a.Teams for a,e in pairs(d)do if e.Team==b and e.TeamColor==c then x(d,a)return true end end return false end function J.IsIgnoredTeam(c)local d=a.Teams if a.IgnoreLocalTeam then return H.TeamMatch(i,c)end for a,d in pairs(d)do if H.TeamMatch(c,d)then return not b.Teams end end return false end function J.IsIgnoredPlayer(c)local d=a.Players for a,d in pairs(d)do local e=b.Players if typeof(d)=="number"and c.UserId==d then return not e end if d==c then return not e end end if b.Players then return true end return false end function J.IsIgnored(a)return J.IsIgnoredPlayer(a)or J.IsIgnoredTeam(a)end function J.TeamCheck(a)if a then return J.IgnoreTeam(i.Team,i.TeamColor)end return J.UnIgnoreTeam(i.Team,i.TeamColor)end end local K={}E.Checks=K do function K.Health(a)local b=H.Character(a)local c=v(b,"Humanoid")local d=c and c.Health or 0 return d>0 end function K.Custom(a)return true end function K.IsAvailable()return D.Enabled==true and E.Selected.Instance~=nil end end function E.GetClosestTargetPartToCursor(a)local b=D.TargetPart local c=nil local d=nil local f=false local h=nil local i=1/0 local function j(b)if typeof(b)=="string"then b=w(a,b)end if not b then return end local j,k=t(I(),b.Position)j=B(j.X,j.Y)local m=z(g)+D.Offset local n=l(e)local o=j-n local p=(o-m).Magnitude if p<i then c=b d=j f=k h=p i=p end end if typeof(b)=="string"then if b=="All"then for a,b in pairs(C(a))do if b:IsA("BasePart")then j(b)end end else j(b)end end if typeof(b)=="table"then for a,b in pairs(b)do j(b)end end return c,d,f,h end local L=nil function E.GetClosestToCursor(a)local b=nil local c=nil local d=nil local e=nil local f=nil local g=H.CalculateChance(D.HitChance)local h=F.Radius local i=E.Selected if not g then i.Instance=nil i.Part=nil i.Position=nil L=nil i.Velocity=nil i.OnScreen=false return end for g,i in pairs(H.GetPlayers())do local j=H.Character(i)if J.IsIgnored(i)==false and j then local g,k,l,m=E.GetClosestTargetPartToCursor(j)if g and(K.Health(i)and K.Custom(i))then if m<h then if D.VisibleCheck and not H.IsPartVisible(g,j)then continue end c=i h=m b=g d=k f=l if not L then L=b.Position end e=H.CalculateVelocity(L,b.Position,a)L=b.Position end end end end if i.Instance~=c then E.Signals:Fire("InstanceChanged",c)end if i.Part~=b then i.Velocity=nil L=nil E.Signals:Fire("PartChanged",b)end if i.Position~=d then E.Signals:Fire("PartPositionChanged",d)end if i.OnScreen~=f then E.Signals:Fire("OnScreenChanged",f)end i.Instance=c i.Part=b i.Position=d i.Velocity=e i.OnScreen=f end E.BeizerCurve={}do local a=b.new()local c=b.new()E.BeizerCurve.ManagerA=a E.BeizerCurve.ManagerB=c local function d()return D.Offset end a.Offset=d c.Offset=d E.BeizerCurve.AimTo=function(...)a:ChangeData(...)end E.BeizerCurve.AimToB=function(...)c:ChangeData(...)end c:CameraMode()c.Function=function(a,b,c)local d=CFrame.fromEulerAnglesYXZ(b,c,0)H.SetCameraCFrame(CFrame.new((I()).CFrame.Position)*d)end a:Start()c:Start()end h:Connect(function(a)E.UpdateFOV()E.UpdateTracer()E.GetClosestToCursor(a)E.Loaded=true end)task.delay(1,function()if E.ShowCredits then messagebox("Thanks to 65pzo","Credits",0)end end)return E